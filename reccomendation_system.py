# -*- coding: utf-8 -*-
"""Reccomendation System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NbDNTkUqYcfzu_VumGPi1z0Mpo5Y56Tb

# Data Understanding

### Load Dataset
"""

import pandas as pd
import numpy as np
import ast

"""- Import Library yang dibutuhkan"""

# Reload the datasets
credits = pd.read_csv("/content/credits.csv")
movies = pd.read_csv("/content/movies.csv")

"""- Simpan dataset credits ke 'credits'
- Simpan dataset movies ke 'movies'
"""

credits.info()

"""- Terdapat 4803 Entries dan 4 Kolom pada dataframe 'credits'
- 4 kolom itu adalah movie_id, title, cast, crew
- Hanya kolom movie_id yang memiliki tipe data 'int64', selebihnya memiliki tipe data 'object'
"""

credits.head()

"""- Menampilkan 5 baris pertama dari dataframe 'credits'"""

credits.nunique()

"""- movie_id memiliki 4803 nilai unik
- title memiliki 4800 nilai unik
- cast memiliki 4761 nilai unik
- crew memiliki 4776 nilai unik
- nilai unik pada movie_id dan title berbeda karena ada indikasi bahwa terdapat judul film yang sama tapi sebenarnya film tersebut berbeda contohnya film Batman dalam dataset tersebut ada dua dan setelah dicek secara manual, kedua film tersebut berbeda sehingga tidak terindikasi sebagai duplikat
"""

movies.info()

"""- Terdapat 4803 entries dan 20 kolom dalam dataframe 'movies'
- Terdapat 13 kolom dengan tipe data 'object', 4 kolom dengan tipe data 'int64', dan 3 kolom dengan tipe data 'float64'
"""

movies.head()

"""- Menampilkan 5 baris pertama dalam dataframe 'movies'"""

movies.nunique()

"""**Insight**

Berikut deskripsi disetiap kolom nya

| No. | Kolom                  | Tipe Data | Deskripsi                                                               |
| --- | ---------------------- | --------- | ----------------------------------------------------------------------- |
| 1   | `budget`               | `int64`   | Anggaran produksi film       |
| 2   | `genres`               | `object`  | List genre film                              |
| 3   | `homepage`             | `object`  | URL situs resmi film (kalau ada).|
| 4   | `id`                   | `int64`   | ID unik untuk setiap film|
| 5   | `keywords`             | `object`  | Kata kunci terkait isi/tema film|
| 6   | `original_language`    | `object`  | Bahasa asli saat film diproduksi (contoh: `en`, `fr`, `ko`, dll).    
| 7   | `original_title`       | `object`  | Judul asli film (kadang beda sama `title`, terutama untuk film asing).  |
| 8   | `overview`             | `object`  | Ringkasan atau sinopsis film.                                           |
| 9   | `popularity`           | `float64` | Skor popularitas (kayaknya dihitung dari views, rating, dll).           |
| 10  | `production_companies` | `object`  | List perusahaan produksi film|
| 11  | `production_countries` | `object`  | Negara tempat produksi film|
| 12  | `release_date`         | `object`  | Tanggal rilis film.|
| 13  | `revenue`              | `int64`   | Pendapatan kotor film|
| 14  | `runtime`              | `float64` | Durasi film dalam menit.|
| 15  | `spoken_languages`     | `object`  | Bahasa yang digunakan dalam film|
| 16  | `status`               | `object`  | Status film (contoh: `Released`, `Post Production', 'Rumored`).|
| 17  | `tagline`              | `object`  | Slogan atau tagline dari film.|
| 18  | `title`                | `object`  | Judul film yang umum diketahui|
| 19  | `vote_average`         | `float64` | Rata-rata rating dari user.|
| 20  | `vote_count`           | `int64`   | Total jumlah vote yang diterima.|

### Data Cleaning
"""

print("Missing values in 'movies' DataFrame:")
print(movies.isnull().sum())

print("\nMissing values in 'credits' DataFrame:")
print(credits.isnull().sum())

"""- Terdapat banyak missing value dari datafram 'movies'
- 3091 missing value dalam kolom 'homepage'
- 3 missing value dalam kolom 'overview'
- 1 missing value dalam kolom 'release_date'
- 2 missing value dalam kolom 'runtime'
- 844 missing value dalam kolom 'tagline'
- Tidak terdapat missing value pada dataframe 'credits'
"""

# Isi nilai kosong dengan string kosong untuk kolom teks
movies['homepage'] = movies['homepage'].fillna('')
movies['overview'] = movies['overview'].fillna('')
movies['tagline'] = movies['tagline'].fillna('')

# Konversi release_date ke datetime dan isi NaT dengan tanggal default
movies['release_date'] = pd.to_datetime(movies['release_date'], errors='coerce')
movies['release_date'] = movies['release_date'].fillna(pd.Timestamp('1900-01-01'))

# Isi runtime yang kosong dengan nilai median
movies['runtime'] = movies['runtime'].fillna(movies['runtime'].median())

# Cek hasil akhir
print(movies.isnull().sum())

"""- Kode tersebut untuk mengatasi missing value yang bisa mengakibatkan error.
- Kolom teks (homepage, overview, tagline) Diisi dengan string kosong, Supaya nggak error waktu diolah pakai string method.
- Kolom tanggal (release_date) Di-convert ke datetime.
- Kolom durasi (runtime) NaN diisi pakai median runtime.
"""

# Cek duplikat berdasarkan seluruh kolom
print("Duplikat di 'movies' (seluruh kolom):", movies.duplicated().sum())
print("Duplikat di 'credits' (seluruh kolom):", credits.duplicated().sum())

# Cek duplikat berdasarkan 'id' atau 'movie_id'
print("Duplikat ID di 'movies':", movies['id'].duplicated().sum())
print("Duplikat ID di 'credits':", credits['movie_id'].duplicated().sum())

"""- Dari output diatas dapat disimpulkan bahwa dalam kedua dataframe tidak ditemukan data yang duplikat"""

# Tampilkan baris duplikat jika ada
print(movies[movies.duplicated()])
print(credits[credits.duplicated()])

"""- Dari kedua dataframe juga tidak ditemukan baris yang duplikat

# Exploratory Data Analysis
"""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 5))
sns.histplot(movies['runtime'].dropna(), bins=40, color='salmon')
plt.title('Distribusi Durasi Film')
plt.xlabel('Durasi (menit)')
plt.ylabel('Jumlah Film')
plt.show()

"""- Kode diatas digunakan untuk membuta visualisasi distribusi durasi film yang dimana waktu durasi nya itu diambil dari kolom 'runtime'
- Grafik menunjukkan bahwa sebagian besar film memiliki durasi antara 90 hingga 120 menit, dengan puncaknya di sekitar 100 menit. Ini mengindikasikan bahwa durasi film yang paling umum atau "standar" berada dalam rentang tersebut.
"""

from collections import Counter
import ast

# Ambil daftar genre
genre_list = []
for g in movies['genres']:
    try:
        genre_list.extend([i['name'] for i in ast.literal_eval(g)])
    except:
        continue

genre_counts = Counter(genre_list)

# Visualisasi 10 genre teratas
top_genres = genre_counts.most_common(10)
genres, counts = zip(*top_genres)

plt.figure(figsize=(10, 5))
sns.barplot(x=list(genres), y=list(counts), palette='viridis')
plt.title('10 Genre Film Terpopuler')
plt.xlabel('Genre')
plt.ylabel('Jumlah')
plt.xticks(rotation=45)
plt.show()

"""- Kode diatas digunakan untuk membuta visualisasi yang berisi 10 genre film terpopuler dalam dataset ini.
- Genre "Drama" adalah yang paling populer secara signifikan, dengan jumlah film melebihi 2250. Ini menunjukkan bahwa film-film drama memiliki representasi yang jauh lebih tinggi dibandingkan genre lainnya dalam dataset ini.
"""

actor_list = []
for c in credits['cast']:
    try:
        actor_list.extend([i['name'] for i in ast.literal_eval(c)[:5]])
    except:
        continue

actor_counts = Counter(actor_list)
top_actors = actor_counts.most_common(10)
actors, counts = zip(*top_actors)

plt.figure(figsize=(10, 5))
sns.barplot(x=list(actors), y=list(counts), palette='magma')
plt.title('10 Aktor Terbanyak Muncul')
plt.xlabel('Aktor')
plt.ylabel('Jumlah Film')
plt.xticks(rotation=45)
plt.show()

"""- Kode diatas digunakan untuk membuta visualisasi yang berisi 10 aktor yang paling sering muncul dalam film
- **Robert De Niro** muncul dalam lebih dari 50 film, menjadikannya aktor dengan penampilan terbanyak dalam dataset ini. **Samuel L. Jackson** berada di posisi kedua dengan lebih dari 40 film, menunjukkan konsistensi dan produktivitas tinggi dari kedua aktor tersebut.
"""

plt.figure(figsize=(10, 5))
sns.histplot(movies['vote_average'], bins=20, color='mediumseagreen')
plt.title('Distribusi Rating Film')
plt.xlabel('Rating')
plt.ylabel('Jumlah Film')
plt.show()

"""- Kode diatas digunakan untuk membuat visualisasi distribusi rating film yang dimana nilai rating nya diambil dari kolom 'vote_average'
- Distribusi rating film menunjukkan puncak yang jelas antara rating 6 hingga 7.5. Ini mengindikasikan bahwa sebagian besar film dalam dataset ini menerima rating yang relatif baik atau di atas rata-rata.
"""

numeric_cols = ['popularity', 'vote_average', 'vote_count', 'revenue', 'runtime']
corr = movies[numeric_cols].corr()

plt.figure(figsize=(8, 6))
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Korelasi Antar Fitur Numerik')
plt.show()

"""- Terdapat korelasi positif yang kuat antara "popularity" dengan "vote_count" (0.78), dan juga antara "vote_count" dengan "revenue" (0.78). Selain itu, "popularity" dan "revenue" juga menunjukkan korelasi positif yang cukup kuat (0.64). Ini mengindikasikan bahwa film yang lebih populer cenderung memiliki jumlah suara (votes) yang lebih tinggi, dan pada gilirannya, cenderung menghasilkan pendapatan (revenue) yang lebih besar.
- Fitur "runtime" (durasi film) menunjukkan korelasi yang relatif lemah dengan semua fitur numerik lainnya, dengan nilai korelasi tidak melebihi 0.37. Ini menyiratkan bahwa durasi film tidak terlalu berhubungan atau memiliki dampak signifikan terhadap popularitas, rata-rata vote, jumlah vote, atau pendapatan film dalam dataset ini.

# Data Preprocessing
"""

# Ambil hanya kolom cast dan crew dari credits
movies = movies.merge(credits[['movie_id', 'cast', 'crew']], left_on='id', right_on='movie_id')

"""- Kode ini melakukan operasi merge (penggabungan) antara dataframe movies dengan dataframe credits. Penggabungan ini dilakukan berdasarkan kolom id di movies dan movie_id di credits. Ini berarti data tentang aktor (cast) dan kru (crew) dari dataframe credits akan ditambahkan ke setiap baris film yang sesuai di dataframe movies."""

movies.columns

"""- Menampilkan semua kolom yang ada pada dataframe 'movies'
- kolom 'cast' dan 'crew' dari dataframe 'credits' telah berhasil digabung kedalam dataframe 'movies'
"""

import ast

# Fungsi bantu
def extract_names(obj_str, key='name', max_items=5):
    try:
        obj_list = ast.literal_eval(obj_str)
        return [obj[key].replace(" ", "").lower() for obj in obj_list[:max_items]]
    except:
        return []

def get_director(obj_str):
    try:
        crew_list = ast.literal_eval(obj_str)
        for member in crew_list:
            if member.get('job') == 'Director':
                return member['name'].replace(" ", "").lower()
        return ''
    except:
        return ''

# Apply ke kolom terkait
movies['genres'] = movies['genres'].apply(lambda x: extract_names(x))
movies['keywords'] = movies['keywords'].apply(lambda x: extract_names(x))
movies['cast'] = movies['cast'].apply(lambda x: extract_names(x, max_items=3))
movies['crew'] = movies['crew'].apply(get_director)

# Pastikan overview bertipe string sebelum .lower()
movies['overview'] = movies['overview'].astype(str)
movies['overview'] = movies['overview'].apply(lambda x: x.lower().split())

# Gabungkan ke kolom tags
movies['tags'] = (
    movies['overview'] +
    movies['genres'] +
    movies['keywords'] +
    movies['cast'] +
    movies['crew'].apply(lambda x: [x] if x else [])
)

# Ubah jadi string
movies['tags'] = movies['tags'].apply(lambda x: " ".join(x))

# Ambil kolom penting
processed_df = movies[['movie_id', 'title', 'tags']].rename(columns={'title': 'title'})

# Cek hasil
print(processed_df.head())

"""- Kode ini secara ekstensif melakukan pra-pemrosesan data tekstual dari beberapa kolom (genres, keywords, cast, crew, overview) dengan tujuan untuk menggabungkannya menjadi satu kolom tags. Proses ini melibatkan ekstraksi nama, normalisasi (mengubah ke huruf kecil, menghapus spasi), dan pembatasan jumlah item. Ini adalah langkah fundamental dalam membangun sistem rekomendasi atau pencarian yang berbasis konten, di mana "tag" akan menjadi representasi komprehensif dari setiap film.
- Kode ini tidak hanya mengekstrak genre dan keywords, tetapi juga memiliki logika khusus untuk mengidentifikasi "Director" dari kolom crew dan membatasi jumlah aktor yang diekstraksi (max_items=3). Pendekatan ini menunjukkan pertimbangan bahwa peran sutradara sangat penting dalam identifikasi sebuah film, sementara hanya beberapa aktor utama yang mungkin paling relevan untuk tujuan penandaan (tagging) atau rekomendasi.

# Model development Content Based Filtering

### Vectorization
"""

from sklearn.feature_extraction.text import TfidfVectorizer

# Batasi jumlah fitur agar ringan dan relevan
tfidf = TfidfVectorizer(max_features=5000, stop_words='english')

# Fit dan transform kolom 'tags'
vectors = tfidf.fit_transform(processed_df['tags']).toarray()

"""- Kode ini menggunakan TfidfVectorizer untuk mengubah data tekstual dari kolom 'tags' menjadi representasi numerik (vektor). TF-IDF (Term Frequency-Inverse Document Frequency) adalah teknik umum yang memberikan bobot pada kata-kata berdasarkan seberapa sering mereka muncul dalam dokumen (film) dan seberapa jarang mereka muncul di seluruh korpus.
- Penggunaan max_features=5000 dan stop_words='english' menunjukkan upaya untuk mengoptimalkan proses vektorisasi. max_features membatasi jumlah kata unik yang akan dipertimbangkan, mengurangi kompleksitas komputasi dan fokus pada kata-kata yang paling informatif. Sementara itu, stop_words='english' menghapus kata-kata umum (seperti "the", "a", "is") yang tidak memberikan banyak makna, sehingga meningkatkan relevansi fitur yang dihasilkan.

### Cosine Similarity
"""

from sklearn.metrics.pairwise import cosine_similarity

similarity = cosine_similarity(vectors)

"""- Kode ini berfungsi untuk menghitung kesamaan kosinus (cosine similarity) antar semua pasangan vektor film. Kesamaan kosinus mengukur sudut antara dua vektor, di mana nilai mendekati 1 menunjukkan kemiripan tinggi (sudut kecil), dan nilai mendekati 0 menunjukkan tidak ada kemiripan (sudut mendekati 90 derajat). Dalam konteks sistem rekomendasi film, ini berarti film-film yang memiliki vektor "tags" yang mirip (berarti memiliki genre, kata kunci, aktor, dan sutradara yang serupa) akan memiliki skor kesamaan kosinus yang tinggi.

### Fungsi Rekomendasi
"""

processed_df['genres'] = movies['genres']

"""- Baris kode processed_df['genres'] = movies['genres'] berfungsi untuk menyalin kolom genres dari dataframe movies ke dataframe processed_df. Artinya, informasi genre dari setiap film akan tersedia juga di dataframe yang sedang diproses lebih lanjut."""

def recommend(movie_title, top_n=5):
    try:
        idx = processed_df[processed_df['title'].str.lower() == movie_title.lower()].index[0]
    except IndexError:
        print("Film tidak ditemukan.")
        return

    distances = list(enumerate(similarity[idx]))
    sorted_movies = sorted(distances, key=lambda x: x[1], reverse=True)[1:top_n+1]

    print(f"\nRekomendasi untuk '{processed_df.iloc[idx]['title']}':")
    for i, (movie_idx, score) in enumerate(sorted_movies, 1):
        title = processed_df.iloc[movie_idx]['title']
        genres = processed_df.iloc[movie_idx]['genres']
        print(f"{i}. {title} | Genre: {genres}")

"""- Kode ini menciptakan sebuah fungsi recommend yang memungkinkan pengguna untuk mendapatkan rekomendasi film berdasarkan judul film yang mereka masukkan.
- Fungsi ini dilengkapi dengan penanganan IndexError jika judul film yang dimasukkan tidak ditemukan, memberikan feedback yang jelas kepada pengguna.
- Selain itu, rekomendasi disajikan secara terurut dari yang paling mirip (kecuali film itu sendiri) hingga sejumlah top_n film yang diinginkan, lengkap dengan judul dan genre, memastikan hasil yang relevan dan informatif bagi pengguna.
"""

recommend("The Dark Knight Rises")

"""- Output menunjukkan bahwa sistem rekomendasi berhasil mengidentifikasi film-film yang sangat relevan dengan "The Dark Knight Rises", seperti "The Dark Knight", "Batman", "Batman Forever", dan "Batman Returns". Ini mengindikasikan bahwa model kemiripan yang dibangun (menggunakan TF-IDF dan cosine similarity pada tag film) bekerja dengan baik dalam menangkap esensi genre, aktor, sutradara, dan kata kunci film, sehingga menghasilkan rekomendasi yang koheren.
- Empat dari lima rekomendasi teratas adalah film Batman lainnya, menegaskan bahwa sistem sangat efektif dalam merekomendasikan bagian dari series yang sama atau film dengan tema dan genre yang sangat mirip. Kehadiran "Slow Burn" sebagai rekomendasi kelima, meskipun bukan bagian dari series Batman, menunjukkan bahwa ada kesamaan genre seperti 'mystery', 'crime', 'drama', dan 'thriller' yang juga dipertimbangkan oleh sistem.

# Evaluasi
"""

import matplotlib.pyplot as plt

# Fungsi Precision@K
def precision_at_k(input_title, k=5, overlap_threshold=5):
    try:
        input_idx = processed_df[processed_df['title'] == input_title].index[0]
    except IndexError:
        return f"Film '{input_title}' tidak ditemukan."

    input_tags = set(movies.iloc[input_idx]['tags'].split())
    sim_scores = list(enumerate(similarity[input_idx]))
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)[1:k+1]

    matched = 0
    for idx, _ in sim_scores:
        compare_tags = set(movies.iloc[idx]['tags'].split())
        overlap = input_tags.intersection(compare_tags)
        if len(overlap) >= overlap_threshold:
            matched += 1

    precision = matched / k
    return precision

# Daftar film uji coba
sample_titles = [
    'The Dark Knight',
    'Inception',
    'The Avengers',
    'Finding Nemo',
    'American Psycho'
]

# Logging & simpan hasil
results = {}

print("📊 Simulasi Precision@5 (overlap threshold ≥ 5):\n")
for title in sample_titles:
    score = precision_at_k(title, k=5, overlap_threshold=5)
    if isinstance(score, str):
        print(f"{title}: {score}")
    else:
        print(f"{title}: Precision@5 = {score:.2f}")
        results[title] = score

# Visualisasi hasil
plt.figure(figsize=(10, 6))
plt.bar(results.keys(), results.values(), color='skyblue')
plt.ylim(0, 1.05)
plt.title("Precision@5 untuk Beberapa Film (CBF)")
plt.ylabel("Precision@5")
plt.xticks(rotation=20)
plt.grid(axis='y', linestyle='--', alpha=0.5)
plt.tight_layout()
plt.show()

"""- Kode ini mengimplementasikan metrik **precision@k** untuk mengevaluasi seberapa akurat sistem rekomendasi. Metrik ini mengukur proporsi rekomendasi yang relevan (didefinisikan berdasarkan overlap tag di atas ambang batas overlap_threshold) di antara k rekomendasi teratas.
- Relevansi rekomendasi didefinisikan secara heuristik melalui jumlah overlap kata kunci/tag antara film input dan film yang direkomendasikan. Dengan overlap_threshold=5, sebuah film dianggap relevan jika memiliki setidaknya 5 tag yang sama dengan film yang menjadi masukan.
- Grafik menunjukkan bahwa sistem rekomendasi mencapai Precision@5 sebesar 1.0 (sempurna) untuk film-film seperti "The Dark Knight", "Inception", dan "The Avengers". Ini mengindikasikan bahwa untuk film-film dengan basis data "tags" yang kaya dan mungkin sangat spesifik atau genre yang jelas, model mampu merekomendasikan 5 film lain yang sangat relevan sesuai dengan kriteria overlap tag.
- Film animasi ("Finding Nemo") mungkin memiliki tag yang lebih terbatas atau berbeda dari film live-action.
- Film seperti "American Psycho" yang mungkin memiliki genre atau tema yang lebih niche atau unik, sehingga lebih sulit menemukan 5 film lain dengan overlap tag yang tinggi.
"""